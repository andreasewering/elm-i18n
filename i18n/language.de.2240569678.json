["Ist das nicht eine triviale Frage? Die Sprache die der User ausgewählt hat. Die Sprache deren Übersetzungen ich sehen kann.\nMoment. Was passiert wenn ich Übersetzungen dynamisch nachlade und der Request noch nicht fertig ist?\nNormalerweise gibt es zwei interessante Sprachen zu einem beliebigen Zeitpunkt.\nDie Sprache in die unsere Anwendung sein sollte, und die Sprache in der unsere Anwendung gerade ist.\nDaher werden für diese beiden Sprachen Funktionen generiert: {H0code|currentLanguage|} and {H0code|arrivedLanguage|}.\nDu kannst den Unterschied live beobachten wenn du in den DevTools die Netzwerkgeschwindigkeit drosselst und die Sprache oben mit einer der Flaggen in der Mitte änderst.\nWenn mehr Logik als das notwendig ist, solltest du vermutlich die Sprache zusätzlich in deinem eigenen Model speichern\n(oder ein Issue aufmachen, vielleicht haben andere Nutzer das gleiche Problem).","Welche Sprache ist aktiv?","Ein Union Typ ist zwar nett, aber zumindest Serialisierung und Deserialisierung zu einem {H0code|String|} ist notwendig um etwas sinnvolles damit anzufangen.\nTravelm-agency generiert {H0code|languageToString|}\nund {H0code|languageFromString|} für dich! Die coole Sache über letztere Methode ist, dass das Matching nicht exakt sondern präfix-basiert ist.\nAlso keine Angst, {H0code|en-US|} wird trotzdem zu {H0code|Just En|} geparsed.","Umwandlungen","Sprachen","Wenn du deine Anwendung ohne travelm-agency bauen würdest, wie würdest du die aktuelle Sprache typisieren.\nIch würde wahrscheinlich einen Union Typ nutzen mit einem Konstruktor pro Sprache. Dieser Code wird auch von\nTravelm-Agency generiert."]