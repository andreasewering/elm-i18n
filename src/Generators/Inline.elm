module Generators.Inline exposing (..)

import CodeGen.Imports
import CodeGen.Shared exposing (Context)
import Dict exposing (Dict)
import Dict.NonEmpty exposing (NonEmpty)
import Elm.CodeGen as CG
import List.NonEmpty
import Set
import State exposing (NonEmptyState, Translation)
import String.Extra
import Types
import Util


toFile : Context -> NonEmptyState () -> CG.File
toFile { moduleName, names, version, languages } state =
    let
        pairs : Types.Translations
        pairs =
            translationSet
                |> Dict.NonEmpty.getFirstEntry
                |> Tuple.second
                |> .pairs
                |> List.sortBy Tuple.first

        translationSet =
            State.collectiveTranslationSet state

        tValueToRecordTypeAnn : Types.TValue -> CG.TypeAnnotation
        tValueToRecordTypeAnn value =
            let
                placeholders =
                    Types.getInterpolationVarNames value |> Set.toList |> List.sort
            in
            case placeholders of
                [] ->
                    CG.stringAnn

                [ _ ] ->
                    CG.funAnn CG.stringAnn CG.stringAnn

                many ->
                    many
                        |> List.map (\name -> ( name, CG.stringAnn ))
                        |> (\fields -> CG.funAnn (CG.recordAnn fields) CG.stringAnn)

        i18nTypeDecl : CG.Declaration
        i18nTypeDecl =
            CG.aliasDecl Nothing
                names.i18nTypeName
                []
                (CG.recordAnn <|
                    List.map (Tuple.mapSecond tValueToRecordTypeAnn) pairs
                )

        i18nDeclForLang : String -> Translation () -> CG.Declaration
        i18nDeclForLang lang translation =
            CG.valDecl (Just (CG.emptyDocComment |> CG.markdown ("`I18n` instance containing all values for the language " ++ String.Extra.classify lang))) (Just <| CG.typed "I18n" []) lang <|
                CG.record (List.map (Tuple.mapSecond inlineTemplate) <| List.sortBy Tuple.first translation.pairs)

        inlineTemplate : Types.TValue -> CG.Expression
        inlineTemplate value =
            let
                placeholders =
                    Types.getInterpolationVarNames value

                accessParam =
                    if Set.size placeholders == 1 then
                        CG.val << Util.safeName

                    else
                        CG.access (CG.val "data_")

                segmentToExpression : Types.TSegment -> CG.Expression
                segmentToExpression segm =
                    case segm of
                        Types.Interpolation var ->
                            accessParam var

                        Types.InterpolationCase var _ ->
                            accessParam var

                        Types.Text text ->
                            CG.string text

                concatenateExpressions e1 e2 =
                    CG.applyBinOp e2 CG.append e1
            in
            List.NonEmpty.map segmentToExpression value
                |> List.NonEmpty.foldl1 concatenateExpressions
                |> (case Set.toList placeholders of
                        [] ->
                            identity

                        [ single ] ->
                            CG.lambda [ CG.varPattern <| Util.safeName single ]

                        _ ->
                            CG.lambda [ CG.varPattern "data_" ]
                   )

        i18nDecls : List CG.Declaration
        i18nDecls =
            Dict.NonEmpty.map i18nDeclForLang translationSet
                |> Dict.NonEmpty.toList
                |> List.map Tuple.second

        declarations =
            i18nTypeDecl :: i18nDecls

        exposed =
            CG.typeOrAliasExpose names.i18nTypeName
                :: List.map CG.funExpose languages

        fileComment =
            CG.emptyFileComment |> CG.markdown ("This file was generated by elm-i18n version " ++ version ++ ".")
    in
    CG.file (CG.normalModule moduleName exposed)
        (CodeGen.Imports.extractImports declarations |> Set.toList |> List.map CodeGen.Imports.basicImport)
        declarations
        (Just fileComment)
