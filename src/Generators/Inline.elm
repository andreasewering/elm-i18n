module Generators.Inline exposing (..)

import CodeGen.Imports
import CodeGen.Shared exposing (Context)
import Dict exposing (Dict)
import Dict.NonEmpty
import Elm.CodeGen as CG
import List.NonEmpty
import Set exposing (Set)
import State exposing (NonEmptyState, Translation)
import String.Extra
import Types
import Util


toFile : Context -> NonEmptyState () -> CG.File
toFile { moduleName, names, version, languages } state =
    let
        pairs : Types.Translations
        pairs =
            translationSet
                |> Dict.NonEmpty.getFirstEntry
                |> Tuple.second
                |> .pairs
                |> List.sortBy Tuple.first

        interpolationMap : Dict Types.TKey (Set String)
        interpolationMap =
            translationSet
                |> Dict.NonEmpty.map (\_ ts -> List.map (Tuple.mapSecond Types.getInterpolationVarNames) ts.pairs |> Dict.fromList)
                |> Dict.NonEmpty.foldl1
                    (\t1 t2 ->
                        Dict.merge
                            Dict.insert
                            (\key s1 s2 -> Dict.insert key <| Set.union s1 s2)
                            Dict.insert
                            t1
                            t2
                            Dict.empty
                    )

        translationSet =
            State.collectiveTranslationSet state

        translationToRecordTypeAnn : Types.TKey -> CG.TypeAnnotation
        translationToRecordTypeAnn key =
            let
                placeholders =
                    Dict.get key interpolationMap
                        |> Maybe.withDefault Set.empty
                        |> Set.toList
                        |> List.sort
            in
            case placeholders of
                [] ->
                    CG.stringAnn

                [ _ ] ->
                    CG.funAnn CG.stringAnn CG.stringAnn

                many ->
                    many
                        |> List.map (\name -> ( name, CG.stringAnn ))
                        |> (\fields -> CG.funAnn (CG.recordAnn fields) CG.stringAnn)

        i18nTypeDecl : CG.Declaration
        i18nTypeDecl =
            CG.aliasDecl Nothing
                names.i18nTypeName
                []
                (CG.recordAnn <|
                    List.map (\( k, _ ) -> ( k, translationToRecordTypeAnn k )) pairs
                )

        i18nDeclForLang : String -> Translation () -> CG.Declaration
        i18nDeclForLang lang translation =
            CG.valDecl (Just (CG.emptyDocComment |> CG.markdown ("`I18n` instance containing all values for the language " ++ String.Extra.classify lang))) (Just <| CG.typed "I18n" []) lang <|
                CG.record (List.map (Tuple.mapSecond inlineTemplate) <| List.sortBy Tuple.first translation.pairs)

        inlineTemplate : Types.TValue -> CG.Expression
        inlineTemplate value =
            let
                placeholders =
                    Types.getInterpolationVarNames value

                accessParam =
                    if Set.size placeholders == 1 then
                        CG.val << Util.safeName

                    else
                        CG.access (CG.val "data_")

                segmentToExpression : Types.TSegment -> CG.Expression
                segmentToExpression segm =
                    case segm of
                        Types.Interpolation var ->
                            accessParam var

                        Types.InterpolationCase var _ ->
                            accessParam var

                        Types.Text text ->
                            CG.string text

                concatenateExpressions e1 e2 =
                    CG.applyBinOp e2 CG.append e1
            in
            List.NonEmpty.map segmentToExpression value
                |> List.NonEmpty.foldl1 concatenateExpressions
                |> (case Set.toList placeholders of
                        [] ->
                            identity

                        [ single ] ->
                            CG.lambda [ CG.varPattern <| Util.safeName single ]

                        _ ->
                            CG.lambda [ CG.varPattern "data_" ]
                   )

        i18nDecls : List CG.Declaration
        i18nDecls =
            Dict.NonEmpty.map i18nDeclForLang translationSet
                |> Dict.NonEmpty.toList
                |> List.map Tuple.second

        declarations =
            i18nTypeDecl :: i18nDecls

        exposed =
            CG.typeOrAliasExpose names.i18nTypeName
                :: List.map CG.funExpose languages

        fileComment =
            CG.emptyFileComment |> CG.markdown ("This file was generated by elm-i18n version " ++ version ++ ".")
    in
    CG.file (CG.normalModule moduleName exposed)
        (CodeGen.Imports.extractImports declarations |> Set.toList |> List.map CodeGen.Imports.basicImport)
        declarations
        (Just fileComment)
