module Generators.Inline exposing (..)

import CodeGen.Imports
import CodeGen.Shared exposing (Context, templateTypeAnn, templateTypeAnnRecord)
import Dict exposing (Dict)
import Dict.NonEmpty exposing (NonEmpty)
import Elm.CodeGen as CG
import List.NonEmpty
import Placeholder.Internal as Placeholder exposing (Template)
import Set
import State exposing (NonEmptyState, State)
import String.Extra
import Types exposing (I18nPairs)
import Util


toFile : Context -> NonEmptyState -> CG.File
toFile { moduleName, names, version, languages } state =
    let
        pairs : I18nPairs
        pairs =
            translationSet |> Dict.NonEmpty.getSomeEntry |> Tuple.second

        translationSet =
            State.collectiveTranslationSet state

        i18nTypeDecl : CG.Declaration
        i18nTypeDecl =
            CG.aliasDecl Nothing
                names.i18nTypeName
                []
                (CG.recordAnn <| List.map (Tuple.mapBoth Util.safeName templateTypeAnn) pairs)

        i18nDeclForLang : String -> I18nPairs -> CG.Declaration
        i18nDeclForLang lang pairsForLanguage =
            CG.valDecl (Just (CG.emptyDocComment |> CG.markdown ("`I18n` instance containing all values for the language " ++ String.Extra.classify lang))) (Just <| CG.typed "I18n" []) lang <|
                CG.record (List.map (Tuple.mapBoth Util.safeName inlineTemplate) pairsForLanguage)

        inlineTemplate : Template -> CG.Expression
        inlineTemplate template =
            Placeholder.getPlaceholderPositions template
                |> List.concatMap (\( indices, name ) -> List.NonEmpty.map (Tuple.pair name) indices |> List.NonEmpty.toList)
                |> List.sortBy Tuple.second
                |> List.map (Tuple.first >> Util.safeName >> CG.val)
                |> List.map2
                    (\segm var ->
                        if segm == "" then
                            var

                        else
                            CG.applyBinOp var CG.append (CG.string segm)
                    )
                    (List.NonEmpty.tail <| Placeholder.getSegments template)
                |> List.foldl (\e1 e2 -> CG.applyBinOp e2 CG.append e1) (CG.string <| List.NonEmpty.head <| Placeholder.getSegments template)
                |> (case Placeholder.getAlphabeticalPlaceholderNames template of
                        [] ->
                            identity

                        nonEmpty ->
                            CG.lambda (nonEmpty |> List.map (Util.safeName >> CG.varPattern))
                   )

        i18nDecls : List CG.Declaration
        i18nDecls =
            Dict.NonEmpty.map i18nDeclForLang translationSet
                |> Dict.NonEmpty.toList
                |> List.map Tuple.second

        accessorDecl : ( String, Template ) -> CG.Declaration
        accessorDecl ( key, template ) =
            let
                placeholders =
                    Placeholder.getAlphabeticalPlaceholderNames template

                placeholderPatterns =
                    case placeholders of
                        [] ->
                            []

                        [ single ] ->
                            [ CG.varPattern <| Util.safeName single ]

                        _ ->
                            [ CG.varPattern "placeholders_" ]

                placeholderFunctionArguments =
                    case placeholders of
                        [] ->
                            []

                        [ single ] ->
                            [ CG.val <| Util.safeName single ]

                        many ->
                            List.map (\name -> CG.access (CG.val "placeholders_") name) many
            in
            CG.funDecl Nothing
                (Just <| CG.funAnn (CG.typed names.i18nTypeName []) (templateTypeAnnRecord template))
                key
                (CG.varPattern "i18n_" :: placeholderPatterns)
                (CG.apply <| CG.access (CG.val "i18n_") (Util.safeName key) :: placeholderFunctionArguments)

        declarations =
            [ i18nTypeDecl ] ++ List.map accessorDecl pairs ++ i18nDecls

        exposed =
            [ CG.typeOrAliasExpose names.i18nTypeName ]
                ++ List.map (Tuple.first >> CG.funExpose) pairs
                ++ List.map CG.funExpose languages

        fileComment =
            CG.emptyFileComment |> CG.markdown ("This file was generated by elm-i18n version " ++ version ++ ".")
    in
    CG.file (CG.normalModule moduleName exposed)
        (CodeGen.Imports.extractImports declarations |> Set.toList |> List.map CodeGen.Imports.basicImport)
        declarations
        (Just fileComment)
