module Generators.Inline exposing (..)

import CodeGen.Imports
import CodeGen.Shared exposing (templateTypeAnn, templateTypeAnnRecord)
import Dict exposing (Dict)
import Dict.NonEmpty exposing (NonEmpty)
import Elm.CodeGen as CG
import List.NonEmpty
import Placeholder.Internal as Placeholder exposing (Template)
import Set
import Types exposing (I18nPairs)
import Util


type alias Context =
    { identifier : String
    , moduleName : CG.ModuleName
    }


toFile : Context -> NonEmpty String I18nPairs -> CG.File
toFile { moduleName } pairsForLanguages =
    let
        i18nName =
            "I18n"

        ( _, pairs ) =
            Dict.NonEmpty.getSomeEntry pairsForLanguages

        languages =
            Dict.NonEmpty.keys pairsForLanguages

        i18nTypeDecl : CG.Declaration
        i18nTypeDecl =
            CG.aliasDecl Nothing
                i18nName
                []
                (CG.recordAnn <| List.map (Tuple.mapBoth Util.safeName templateTypeAnn) pairs)

        i18nDeclForLang : String -> I18nPairs -> CG.Declaration
        i18nDeclForLang lang pairsForLanguage =
            CG.valDecl Nothing (Just <| CG.typed "I18n" []) lang <|
                CG.record (List.map (Tuple.mapBoth Util.safeName inlineTemplate) pairsForLanguage)

        inlineTemplate : Template -> CG.Expression
        inlineTemplate template =
            Placeholder.getPlaceholderPositions template
                |> List.concatMap (\( indices, name ) -> List.NonEmpty.map (Tuple.pair name) indices |> List.NonEmpty.toList)
                |> List.sortBy Tuple.second
                |> List.map (Tuple.first >> Util.safeName >> CG.val)
                |> List.map2
                    (\segm var ->
                        if segm == "" then
                            var

                        else
                            CG.applyBinOp var CG.append (CG.string segm)
                    )
                    (List.NonEmpty.tail <| Placeholder.getSegments template)
                |> List.foldl (\e1 e2 -> CG.applyBinOp e2 CG.append e1) (CG.string <| List.NonEmpty.head <| Placeholder.getSegments template)
                |> (case Placeholder.getAlphabeticalPlaceholderNames template of
                        [] ->
                            identity

                        nonEmpty ->
                            CG.lambda (nonEmpty |> List.map (Util.safeName >> CG.varPattern))
                   )

        i18nDecls : List CG.Declaration
        i18nDecls =
            Dict.NonEmpty.map i18nDeclForLang pairsForLanguages
                |> Dict.NonEmpty.toList
                |> List.map Tuple.second

        accessorDecl : ( String, Template ) -> CG.Declaration
        accessorDecl ( key, template ) =
            let
                placeholders =
                    Placeholder.getAlphabeticalPlaceholderNames template

                placeholderPatterns =
                    case placeholders of
                        [] ->
                            []

                        [ single ] ->
                            [ CG.varPattern <| Util.safeName single ]

                        _ ->
                            [ CG.varPattern "placeholders_" ]

                placeholderFunctionArguments =
                    case placeholders of
                        [] ->
                            []

                        [ single ] ->
                            [ CG.val <| Util.safeName single ]

                        many ->
                            List.map (\name -> CG.access (CG.val "placeholders_") name) many
            in
            CG.funDecl Nothing
                (Just <| CG.funAnn (CG.typed i18nName []) (templateTypeAnnRecord template))
                key
                (CG.varPattern "i18n_" :: placeholderPatterns)
                (CG.apply <| CG.access (CG.val "i18n_") (Util.safeName key) :: placeholderFunctionArguments)

        declarations =
            [ i18nTypeDecl ] ++ List.map accessorDecl pairs ++ i18nDecls

        exposed =
            [ CG.typeOrAliasExpose i18nName ]
                ++ List.map (Tuple.first >> CG.funExpose) pairs
                ++ List.map CG.funExpose languages

        fileComment =
            CG.emptyFileComment |> CG.markdown "This file was generated by elm-i18n."
    in
    CG.file (CG.normalModule moduleName exposed)
        (CodeGen.Imports.extractImports declarations |> Set.toList |> List.map CodeGen.Imports.basicImport)
        declarations
        (Just fileComment)
