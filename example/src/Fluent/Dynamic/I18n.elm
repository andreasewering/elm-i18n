module Fluent.Dynamic.I18n exposing (I18n, Language(..), attributes, attributesTitle, attributesWithVarAndTerm, compileTimeDatesAndNumbers, dateTimeFun, decodeDemo, dynamicTermKey, init, languageFromString, languageToFileName_demo, languageToString, languages, loadDemo, matchOnStrings, nestedTermKey, numberFun, staticTermKey)

{-| This file was generated by elm-i18n version 2.4.0.


-}

import Array
import Http
import Intl
import Json.Decode
import Maybe
import Parser exposing ((|.), (|=))
import Result
import String
import Time


type I18n
    = I18n { demo : Array.Array String } Intl.Intl Language


{-| Initialize an (empty) `I18n` instance. This is useful on startup when no JSON was `load`ed yet.


-}
init : Intl.Intl -> Language -> I18n
init intl_ lang_ =
    I18n { demo = Array.empty } intl_ lang_


fallbackValue_ : String
fallbackValue_ =
    "..."


{-| Replaces all placeholders with the given arguments using the Intl API on the marked spots


-}
replacePlaceholders : I18n -> List String -> String -> String
replacePlaceholders (I18n _ intl_ lang_) argList_ =
    let
        args_ =
            Array.fromList argList_

        getArg_ n_ =
            Array.get n_ args_ |> Maybe.withDefault ""

        wrappedLang_ =
            "\"" ++ languageToString lang_ ++ "\""

        argParser_ =
            Parser.oneOf
                [ Parser.succeed wrappedLang_ |. Parser.token "}"
                , Parser.succeed (\str_ -> wrappedLang_ ++ ",{" ++ str_ ++ "}")
                    |= (Parser.chompUntil "}" |> Parser.getChompedString)
                    |. Parser.token "}"
                ]

        numberFormatUnsafe_ n_ parsedArgString_ =
            Maybe.withDefault "" <|
                Intl.unsafeAccess intl_ <|
                    "[\"NumberFormat\",[" ++ parsedArgString_ ++ "],\"format\",[" ++ getArg_ n_ ++ "]]"

        dateFormatUnsafe_ n_ parsedArgString_ =
            Maybe.withDefault "" <|
                Intl.unsafeAccess intl_ <|
                    "[\"DateTimeFormat\",[" ++ parsedArgString_ ++ "],\"format\",[" ++ getArg_ n_ ++ "]]"

        parser_ =
            Parser.loop "" <|
                \state_ ->
                    Parser.oneOf
                        [ Parser.succeed ((++) state_ >> Parser.Loop)
                            |. Parser.token "{"
                            |= Parser.oneOf
                                [ Parser.succeed getArg_ |= Parser.int |. Parser.token "}"
                                , Parser.succeed numberFormatUnsafe_ |. Parser.token "N" |= Parser.int |= argParser_
                                , Parser.succeed dateFormatUnsafe_ |. Parser.token "D" |= Parser.int |= argParser_
                                ]
                        , Parser.chompUntilEndOr "{"
                            |> Parser.getChompedString
                            |> Parser.map ((++) state_)
                            |> Parser.andThen
                                (\str_ ->
                                    Parser.oneOf
                                        [ Parser.succeed (Parser.Done str_) |. Parser.end
                                        , Parser.succeed (Parser.Loop str_)
                                        ]
                                )
                        ]
    in
    Parser.run parser_ >> Result.toMaybe >> Maybe.withDefault ""


{-| Enumeration of the supported languages


-}
type Language
    = De
    | En
    | Fr


{-| A list containing all `Language`s


-}
languages : List Language
languages =
    [ De, En, Fr ]


{-| Convert a `Language` to its `String` representation.


-}
languageToString : Language -> String
languageToString lang_ =
    case lang_ of
        De ->
            "de"

        En ->
            "en"

        Fr ->
            "fr"


{-| Maybe parse a `Language` from a `String`. 
This only considers the keys given during compile time, if you need something like 'en-US' to map to the correct `Language`,
you should write your own parsing function.


-}
languageFromString : String -> Maybe Language
languageFromString lang_ =
    case lang_ of
        "de" ->
            Just De

        "en" ->
            Just En

        "fr" ->
            Just Fr

        _ ->
            Nothing


attributes : I18n -> String
attributes (I18n { demo } _ _) =
    case Array.get 0 demo of
        Just translation_ ->
            translation_

        Nothing ->
            fallbackValue_


attributesTitle : I18n -> String
attributesTitle (I18n { demo } _ _) =
    case Array.get 1 demo of
        Just translation_ ->
            translation_

        Nothing ->
            fallbackValue_


attributesWithVarAndTerm : I18n -> String -> String
attributesWithVarAndTerm ((I18n { demo } _ _) as i18n_) var_ =
    case Array.get 2 demo of
        Just translation_ ->
            replacePlaceholders i18n_ [ var_ ] translation_

        Nothing ->
            fallbackValue_


compileTimeDatesAndNumbers : I18n -> String
compileTimeDatesAndNumbers (I18n { demo } _ _) =
    case Array.get 3 demo of
        Just translation_ ->
            translation_

        Nothing ->
            fallbackValue_


dateTimeFun : I18n -> Time.Posix -> String
dateTimeFun ((I18n { demo } _ _) as i18n_) date_ =
    case Array.get 4 demo of
        Just translation_ ->
            replacePlaceholders i18n_ [ String.fromInt <| Time.posixToMillis date_ ] translation_

        Nothing ->
            fallbackValue_


dynamicTermKey : I18n -> String -> String
dynamicTermKey ((I18n { demo } _ _) as i18n_) adjective_ =
    case Array.get 5 demo of
        Just translation_ ->
            replacePlaceholders i18n_ [ adjective_ ] translation_

        Nothing ->
            fallbackValue_


matchOnStrings : I18n -> String -> String
matchOnStrings ((I18n { demo } _ _) as i18n_) gender_ =
    case Array.get 6 demo of
        Just translation_ ->
            replacePlaceholders i18n_ [ gender_ ] translation_

        Nothing ->
            fallbackValue_


nestedTermKey : I18n -> String
nestedTermKey (I18n { demo } _ _) =
    case Array.get 7 demo of
        Just translation_ ->
            translation_

        Nothing ->
            fallbackValue_


numberFun : I18n -> Float -> String
numberFun ((I18n { demo } _ _) as i18n_) num_ =
    case Array.get 8 demo of
        Just translation_ ->
            replacePlaceholders i18n_ [ String.fromFloat num_ ] translation_

        Nothing ->
            fallbackValue_


staticTermKey : I18n -> String
staticTermKey (I18n { demo } _ _) =
    case Array.get 9 demo of
        Just translation_ ->
            translation_

        Nothing ->
            fallbackValue_


{-| Decode an `I18n` from Json. Make sure this is *only* used on the files generated by this package.


-}
decodeDemo : Json.Decode.Decoder (I18n -> I18n)
decodeDemo =
    Json.Decode.array Json.Decode.string
        |> Json.Decode.map (\arr_ (I18n i18n_ intl_ lang_) -> I18n { i18n_ | demo = arr_ } intl_ lang_)


{-| 
Load translations for identifier 'demo' and a `Language` from the server. This is a simple `Http.get`, if you need more customization,
you can use the `decoder` instead. Pass the path and a callback to your `update` function, for example

    load { language = De, path = "/i18n", onLoad = GotTranslations }

will make a `GET` request to /i18n/demo.de.2638879814.json and will call GotTranslations with the decoded response.


-}
loadDemo : { language : Language, path : String, onLoad : Result Http.Error (I18n -> I18n) -> msg } -> Cmd msg
loadDemo opts_ =
    Http.get
        { expect = Http.expectJson opts_.onLoad decodeDemo
        , url = opts_.path ++ "/" ++ languageToFileName_demo opts_.language
        }


languageToFileName_demo : Language -> String
languageToFileName_demo lang_ =
    case lang_ of
        De ->
            "demo.de.2638879814.json"

        En ->
            "demo.en.3573976388.json"

        Fr ->
            "demo.fr.3666794962.json"
