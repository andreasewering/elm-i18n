module Dynamic.I18n exposing (I18n, Language(..), decodeMessages, differentVars, greeting, init, languageFromString, languageSwitchInfo, languageToFileName_messages, languageToString, languages, loadMessages, orderDemo, specialCharacters, staticText)

{-| This file was generated by elm-i18n version 2.7.0.
-}

import Array
import Http
import Json.Decode
import List
import Maybe
import String
import Tuple


type I18n
    = I18n { messages : Array.Array String }


{-| Initialize an (empty) `I18n` instance. This is useful on startup when no JSON was `load`ed yet.
-}
init : I18n
init =
    I18n { messages = Array.empty }


{-| Enumeration of the supported languages
-}
type Language
    = De
    | En
    | Fr


{-| A list containing all `Language`s. The list is sorted alphabetically.
-}
languages : List Language
languages =
    [ De, En, Fr ]


{-| Convert a `Language` to its `String` representation.
-}
languageToString : Language -> String
languageToString lang =
    case lang of
        De ->
            "de"

        En ->
            "en"

        Fr ->
            "fr"


{-| Maybe parse a `Language` from a `String`.
This will map languages based on the prefix i.e. 'en-US' and 'en' will both map to 'En' unless you provided a 'en-US' translation file.
-}
languageFromString : String -> Maybe Language
languageFromString lang =
    let
        helper langs =
            case langs of
                [] ->
                    Maybe.Nothing

                l :: ls ->
                    if String.startsWith (languageToString l) lang then
                        Maybe.Just l

                    else
                        helper ls
    in
    helper (List.reverse languages)


{-| Load translations for identifier 'messages' and a `Language` from the server. This is a simple `Http.get`, if you need more customization,
you can use the `decoder` instead. Pass the path and a callback to your `update` function, for example

    load { language = De, path = "/i18n", onLoad = GotTranslations }

will make a `GET` request to /i18n/messages.de.4271012564.json and will call GotTranslations with the decoded response.

-}
loadMessages : { language : Language, path : String, onLoad : Result Http.Error (I18n -> I18n) -> msg } -> Cmd msg
loadMessages opts =
    Http.get
        { expect = Http.expectJson opts.onLoad decodeMessages
        , url = opts.path ++ "/" ++ languageToFileName_messages opts.language
        }


differentVars : I18n -> { a | elmEn : String, unionGer : String } -> String
differentVars (I18n { messages }) data =
    case Array.get 0 messages of
        Just translation ->
            replacePlaceholders [ data.elmEn, data.unionGer ] translation

        Nothing ->
            fallbackValue


greeting : I18n -> String -> String
greeting (I18n { messages }) name =
    case Array.get 1 messages of
        Just translation ->
            replacePlaceholders [ name ] translation

        Nothing ->
            fallbackValue


languageSwitchInfo : I18n -> String -> String
languageSwitchInfo (I18n { messages }) currentLanguage =
    case Array.get 2 messages of
        Just translation ->
            replacePlaceholders [ currentLanguage ] translation

        Nothing ->
            fallbackValue


orderDemo : I18n -> { a | language : String, name : String } -> String
orderDemo (I18n { messages }) data =
    case Array.get 3 messages of
        Just translation ->
            replacePlaceholders [ data.language, data.name ] translation

        Nothing ->
            fallbackValue


specialCharacters : I18n -> String
specialCharacters (I18n { messages }) =
    case Array.get 4 messages of
        Just translation ->
            translation

        Nothing ->
            fallbackValue


staticText : I18n -> String
staticText (I18n { messages }) =
    case Array.get 5 messages of
        Just translation ->
            translation

        Nothing ->
            fallbackValue


{-| Decode an `I18n` from Json. Make sure this is _only_ used on the files generated by this package.
-}
decodeMessages : Json.Decode.Decoder (I18n -> I18n)
decodeMessages =
    Json.Decode.array Json.Decode.string |> Json.Decode.map (\arr (I18n i18n) -> I18n { i18n | messages = arr })


fallbackValue : String
fallbackValue =
    "..."


{-| Replaces all placeholder expressions in a string in order with the given values
-}
replacePlaceholders : List String -> String -> String
replacePlaceholders list str =
    List.foldl (\val ( i, acc ) -> ( i + 1, String.replace ("{" ++ String.fromInt i ++ "}") val acc )) ( 0, str ) list
        |> Tuple.second


languageToFileName_messages : Language -> String
languageToFileName_messages lang =
    case lang of
        De ->
            "messages.de.4271012564.json"

        En ->
            "messages.en.2397054257.json"

        Fr ->
            "messages.fr.4224922667.json"
