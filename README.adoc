= 🌎 Elm I18n 

This package is a library and an executable to generate Elm Modules from different common I18n formats.

== 🔍 Feature Overview 

[none]
* ✔️ Supports .json and .properties files as input
* 🕵️‍♂️ Errors out if i18n keys are inconsistent across languages
* 🚀 Key length and placeholder length do not impact resource size 
* ✨ Decodes values with placeholders into Elm functions
* 🔑 Generated Elm module exposes functions based on keys
* 🎌 Simple runtime switching of languages
* 🎚️ Choose between inline code generation and dynamic loading based code generation
* 🖋️ Node API is written in Typescript


== 📖 How to use

. Install this package from npm with `npm install --save-dev elm-i18n`.

. Put your translations in files of one of the supported formatsand bundle them in a folder. The filenames should follow the pattern `[identifier].[language].[extension]`.
. Choose a filepath for the generated Elm file.
. Choose a folder for the JSON output
. Run the script with one of the methods described below
. Follow the output documentation to actually run the code

=== ⌨️ Script usage

Run 
-----
npx elm-i18n --elm_path=src/I18n.elm --json_path=dist/i18n [folder with translation files]
-----

Alternatively, add a script to your `package.json` with the content
-----
elm-i18n --elm_path=src/I18n.elm --json_path=dist/i18n [folder with translation files]
-----

and then run that script with `npm run [scriptname]`.

=== 📦 Usage as a node module

If you need more customizable behaviour, or need to embed this inside a more complex script or plugin, you can import this module 
in a js or ts file and go from there.

Let the types guide you 🦮.

== Embedding the output in your application

To use the output generated by this package in your application, the general idea is to store the active translations inside your `Model` and load translations on `init` and on demand. To do that, you send an HTTP request to get the generated JSON file from your server and use the generated `decoder` to parse the response.

In your view, you can access your translations by the exposed accessor functions of the generated Elm module.

View the /example directory for working code.

== Inline vs Dynamic

The two example applications clock in at
~34KB (inline) and ~47KB (dynamic) respectively. The comparison might not be entirely fair, since code from `Http` or `Parser` might end up in your application regardless, but this basically means that inline is going to be the better choice most of the time. The .json files are less than a KB in this case. Will benchmark a larger application later.

