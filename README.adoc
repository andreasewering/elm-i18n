:toc:
= 🌎 Travelm Agency 

This package is a library and an executable to generate Elm Modules from different common I18n formats.


== 🔍 Feature Overview 

[none]
* ✔️ Supports .json and .properties files as input
* 🕵️‍♂️ Errors out if i18n keys are inconsistent across languages
* 🚀 Key length and placeholder length do not impact resource size 
* ✨ Generates Elm functions for values with placeholders
* 🔑 Generated Elm module exposes functions based on keys
* 🎌 Simple runtime switching of languages
* 🎚️ Choose between inline code generation and dynamic loading based code generation
* ♾️ Optional hashing of generated filenames for infinite browser caching
* 🖋️ Node API is written in Typescript


== 📖 How to use

. Install this package from npm with `npm install --save-dev elm-i18n`.

. Put your translations in files of one of the supported formats and bundle them in a folder. The filenames should follow the pattern `[identifier].[language].[extension]`.
. Choose a filepath for the generated Elm file.
. Choose a folder for the JSON output
. Run the script with one of the methods described below
. Follow the output documentation to actually run the code

=== ⌨️ Script usage

Run 

====
npx travelm-agency --elm_path=src/I18n.elm --json_path=dist/i18n [folder with translation files]
====

[NOTE]
====
`--json_path` is not necessary when you use `--inline` mode.
====

Alternatively, add a script to your `package.json` with the content
====
travelm-agency --elm_path=src/I18n.elm --json_path=dist/i18n [folder with translation files]
====

and then run that script with `npm run [scriptname]`.

For more information on command line options, run `npx travelm-agency --help`.


=== 📦 Usage as a node module

If you need more customizable behaviour, or need to embed this inside a more complex script or plugin, you can import this module 
in a js or ts file and go from there.

Let the types guide you 🦮.

== 🌯 Embedding the output in your application

To use the output generated by this package in your application, the general idea is to store the active translations inside your `Model` and load translations on `init` and on demand. To do that, you call the generated `load` function, sending an HTTP request to get the generated JSON file from your server. The update to your translations will then go in your main `update` function, where you can update your `Model`. 

In your view, you can access your translations by using the exposed accessor functions of the generated Elm module.

View the /example directory for working code.

== ▶️ Inline vs Dynamic

The two example applications clock in at
~34KB (inline) and ~35KB (dynamic) respectively. The comparison might not be entirely fair, since code from `Http` might end up in your application regardless, also the .json files are less than a KB in this case.

I introduced this package in one of my webapps and with 15 key/value pairs and 2 languages, the dynamic variant started winning slightly.

== 🙄 Why another i18n solution

Here are some other i18n solutions with their differences:
[cols="1,3"]
|===
| https://github.com/yonigibbs/elm-i18next-gen[elm-i18next-gen]
| Allows you to access your translations object in unsafe ways via the Translation API, but also more freedom. I like the approach of using Dict internally and not storing functions inside of the model. It made me switch my internal dynamic representation from a custom record into an Array. Also generates a lot of modules instead of one module with all translations.

| https://github.com/iosphere/elm-i18n[elm-i18n]
| Generates a whole extra js bundle for each language. This makes initial load time optimal, but language switching during runtime more difficult. I like the approach because the user usually does not switch languages very often. I might write a frontend using this technique as well. The main issue here is that I have no idea how to use this together with a bundler like webpack.

| https://github.com/dragonwasrobot/i18n-to-elm[i18n-to-elm]
| This chooses the --inline approach of this module. I like to be flexible and have an option to switch to/benchmark runtime loading

| https://github.com/ChristophP/elm-i18n-module-generator[elm-i18n-module-generator]
| Also an inline approach, this time using a language union type.
|===

Interestingly enough, none of these seem to have explored the possibility of optimizing the i18n .json files.
Also, I really enjoy metaprogramming Elm using Elm itself, so that is probably why I built this although the other solutions are perfectly fine.