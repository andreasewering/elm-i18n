module Generators.DynamicTest exposing (..)

import CodeGen.Shared exposing (Context)
import Dict.NonEmpty
import Elm.Pretty
import Expect
import Generators.Dynamic as Dynamic
import Generators.Names exposing (defaultNames)
import State exposing (NonEmptyState, OptimizedJson)
import Test exposing (Test, describe, test)
import Types exposing (TSegment(..), Translations)


context : Context
context =
    { version = "1.0.0", moduleName = [ "Test" ], names = defaultNames, languages = [ "en" ] }


simpleState : Translations -> NonEmptyState OptimizedJson
simpleState translations =
    Dict.NonEmpty.singleton "messages" <|
        Dict.NonEmpty.singleton "en" { pairs = translations, resources = { filename = "messages.1234.json", content = "" } }


suite : Test
suite =
    describe "Dynamic Generator"
        [ test "single language" <|
            \_ ->
                simpleState
                    [ ( "key3", ( Text "value3 ", [ Interpolation "bla", Interpolation "blub" ] ) )
                    , ( "key1", ( Text "value1", [] ) )
                    , ( "key2", ( Text "value2 ", [ Interpolation "bla" ] ) )
                    ]
                    |> Dynamic.toFile context
                    |> Elm.Pretty.pretty 120
                    |> Expect.equal """module Test exposing (I18n, Language(..), decodeMessages, init, key1, key2, key3, languageFromString, languageToFileName_messages, languageToString, languages, loadMessages)

{-| This file was generated by elm-i18n version 1.0.0.


-}

import Array
import Http
import Json.Decode
import List
import String
import Tuple


type I18n
    = I18n { messages : Array.Array String }


{-| Initialize an (empty) `I18n` instance. This is useful on startup when no JSON was `load`ed yet.


-}
init : I18n
init =
    I18n { messages = Array.empty }


{-| Enumeration of the supported languages


-}
type Language
    = En


{-| A list containing all `Language`s


-}
languages : List Language
languages =
    [ En ]


{-| Convert a `Language` to its `String` representation.


-}
languageToString : Language -> String
languageToString lang_ =
    case lang_ of
        En ->
            "en"


{-| Maybe parse a `Language` from a `String`. 
This only considers the keys given during compile time, if you need something like 'en-US' to map to the correct `Language`,
you should write your own parsing function.


-}
languageFromString : String -> Maybe Language
languageFromString lang_ =
    case lang_ of
        "en" ->
            Just En

        _ ->
            Nothing


fallbackValue_ : String
fallbackValue_ =
    "..."


{-| Replaces all placeholder expressions in a string in order with the given values


-}
replacePlaceholders : List String -> String -> String
replacePlaceholders list_ str_ =
    List.foldl
        (\\val_ ( i_, acc_ ) -> ( i_ + 1, String.replace ("{" ++ String.fromInt i_ ++ "}") val_ acc_ ))
        ( 0, str_ )
        list_
        |> Tuple.second


key3 : I18n -> { a | bla : String, blub : String } -> String
key3 (I18n { messages }) placeholders_ =
    case Array.get 0 messages of
        Just translation_ ->
            replacePlaceholders [ placeholders_.bla, placeholders_.blub ] translation_

        Nothing ->
            fallbackValue_


key1 : I18n -> String
key1 (I18n { messages }) =
    case Array.get 1 messages of
        Just translation_ ->
            translation_

        Nothing ->
            fallbackValue_


key2 : I18n -> String -> String
key2 (I18n { messages }) bla_ =
    case Array.get 2 messages of
        Just translation_ ->
            replacePlaceholders [ bla_ ] translation_

        Nothing ->
            fallbackValue_


{-| Decode an `I18n` from Json. Make sure this is *only* used on the files generated by this package.


-}
decodeMessages : Json.Decode.Decoder (I18n -> I18n)
decodeMessages =
    Json.Decode.array Json.Decode.string |> Json.Decode.map (\\arr_ (I18n i18n_) -> I18n { i18n_ | messages = arr_ })


{-| 
Load translations for identifier 'messages' and a `Language` from the server. This is a simple `Http.get`, if you need more customization,
you can use the `decoder` instead. Pass the path and a callback to your `update` function, for example

    load { language = En, path = "/i18n", onLoad = GotTranslations }

will make a `GET` request to /i18n/messages.1234.json and will call GotTranslations with the decoded response.


-}
loadMessages : { language : Language, path : String, onLoad : Result Http.Error (I18n -> I18n) -> msg } -> Cmd msg
loadMessages opts_ =
    Http.get
        { expect = Http.expectJson opts_.onLoad decodeMessages
        , url = opts_.path ++ "/" ++ languageToFileName_messages opts_.language
        }


languageToFileName_messages : Language -> String
languageToFileName_messages lang_ =
    case lang_ of
        En ->
            "messages.1234.json"
"""
        ]
