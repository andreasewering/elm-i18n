module Generators.InlineTest exposing (..)

import CodeGen.Shared exposing (Context)
import Dict.NonEmpty
import Elm.Pretty
import Expect
import Generators.Inline as Inline
import Generators.Names exposing (defaultNames)
import State exposing (NonEmptyState, Translations)
import Test exposing (Test, describe, test)
import Types.Segment as Segment
import Util exposing (emptyIntl)


context : Context
context =
    { version = "1.0.0", moduleName = [ "Test" ], names = defaultNames, intl = emptyIntl }


simpleState : Translations -> NonEmptyState ()
simpleState translations =
    Dict.NonEmpty.singleton "messages" <|
        Dict.NonEmpty.singleton "en" { pairs = translations, resources = () }


suite : Test
suite =
    describe "Inline Generator"
        [ test "single language" <|
            \_ ->
                simpleState
                    [ ( "key3", ( Segment.Text "value3 ", [ Segment.Interpolation "bla", Segment.Interpolation "blub" ] ) )
                    , ( "key1", ( Segment.Text "value1", [] ) )
                    , ( "key2", ( Segment.Text "value2 ", [ Segment.Interpolation "bla" ] ) )
                    ]
                    |> Inline.toFile context
                    |> Elm.Pretty.pretty 120
                    |> Expect.equal """module Test exposing (I18n, Language(..), en, init, key1, key2, key3, languageFromString, languageToString, languages, load)

{-| This file was generated by elm-i18n version 1.0.0.


-}


type alias I18n =
    { key1_ : String, key2_ : String -> String, key3_ : { bla : String, blub : String } -> String }


{-| Initialize an i18n instance based on a language


-}
init : Language -> I18n
init lang_ =
    case lang_ of
        En ->
            en


{-| Switch to another i18n instance based on a language


-}
load : Language -> I18n -> I18n
load lang_ _ =
    init lang_


{-| `I18n` instance containing all values for the language En


-}
en : I18n
en =
    { key1_ = "value1", key2_ = \\bla_ -> "value2 " ++ bla_, key3_ = \\data_ -> "value3 " ++ data_.bla ++ data_.blub }


{-| Enumeration of the supported languages


-}
type Language
    = En


{-| A list containing all `Language`s


-}
languages : List Language
languages =
    [ En ]


{-| Convert a `Language` to its `String` representation.


-}
languageToString : Language -> String
languageToString lang_ =
    case lang_ of
        En ->
            "en"


{-| Maybe parse a `Language` from a `String`. 
This only considers the keys given during compile time, if you need something like 'en-US' to map to the correct `Language`,
you should write your own parsing function.


-}
languageFromString : String -> Maybe Language
languageFromString lang_ =
    case lang_ of
        "en" ->
            Just En

        _ ->
            Nothing


key1 : I18n -> String
key1 i18n_ =
    i18n_.key1_


key2 : I18n -> String -> String
key2 i18n_ =
    i18n_.key2_


key3 : I18n -> { bla : String, blub : String } -> String
key3 i18n_ =
    i18n_.key3_
"""
        , test "multiple languages with different placeholder names" <|
            \_ ->
                (Dict.NonEmpty.singleton "messages" <|
                    Dict.NonEmpty.fromList
                        ( ( "de"
                          , { pairs =
                                [ ( "key"
                                  , ( Segment.Text "value "
                                    , [ Segment.Interpolation "bla", Segment.Interpolation "blub" ]
                                    )
                                  )
                                ]
                            , resources = ()
                            }
                          )
                        , [ ( "en"
                            , { pairs =
                                    [ ( "key"
                                      , ( Segment.Interpolation "howdy"
                                        , [ Segment.Text "text", Segment.Interpolation "blub" ]
                                        )
                                      )
                                    ]
                              , resources = ()
                              }
                            )
                          ]
                        )
                )
                    |> Inline.toFile context
                    |> Elm.Pretty.pretty 120
                    |> Expect.equal """module Test exposing (I18n, Language(..), de, en, init, key, languageFromString, languageToString, languages, load)

{-| This file was generated by elm-i18n version 1.0.0.


-}


type alias I18n =
    { key_ : { bla : String, blub : String, howdy : String } -> String }


{-| Initialize an i18n instance based on a language


-}
init : Language -> I18n
init lang_ =
    case lang_ of
        De ->
            de

        En ->
            en


{-| Switch to another i18n instance based on a language


-}
load : Language -> I18n -> I18n
load lang_ _ =
    init lang_


{-| `I18n` instance containing all values for the language De


-}
de : I18n
de =
    { key_ = \\data_ -> "value " ++ data_.bla ++ data_.blub }


{-| `I18n` instance containing all values for the language En


-}
en : I18n
en =
    { key_ = \\data_ -> data_.howdy ++ "text" ++ data_.blub }


{-| Enumeration of the supported languages


-}
type Language
    = De
    | En


{-| A list containing all `Language`s


-}
languages : List Language
languages =
    [ De, En ]


{-| Convert a `Language` to its `String` representation.


-}
languageToString : Language -> String
languageToString lang_ =
    case lang_ of
        De ->
            "de"

        En ->
            "en"


{-| Maybe parse a `Language` from a `String`. 
This only considers the keys given during compile time, if you need something like 'en-US' to map to the correct `Language`,
you should write your own parsing function.


-}
languageFromString : String -> Maybe Language
languageFromString lang_ =
    case lang_ of
        "de" ->
            Just De

        "en" ->
            Just En

        _ ->
            Nothing


key : I18n -> { bla : String, blub : String, howdy : String } -> String
key i18n_ =
    i18n_.key_
"""
        ]
