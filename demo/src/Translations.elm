module Translations exposing (I18n, Language(..), decodeIntro, headline, init, inputType, inputTypeFluent, inputTypeJson, inputTypeProperties, languageFromString, languageToFileName_intro, languageToString, languages, loadIntro, stepOne, stepThree, stepTwo)

{-| This file was generated by travelm-agency version 2.8.4.

If you have any issues with the generated code, do not hesitate to open an issue here: <https://github.com/andreasewering/travelm-agency/issues>

-}

import Array
import Char
import Http
import Json.Decode
import List
import Maybe
import Parser
import String


type I18n
    = I18n { intro : Array.Array String }


{-| Initialize an (empty) `I18n` instance. This is useful on startup when no JSON was `load`ed yet.
-}
init : I18n
init =
    I18n { intro = Array.empty }


{-| Enumeration of the supported languages
-}
type Language
    = En


{-| A list containing all `Language`s. The list is sorted alphabetically.
-}
languages : List Language
languages =
    [ En ]


{-| Convert a `Language` to its `String` representation.
-}
languageToString : Language -> String
languageToString lang =
    case lang of
        En ->
            "en"


{-| Maybe parse a `Language` from a `String`.
This will map languages based on the prefix i.e. 'en-US' and 'en' will both map to 'En' unless you provided a 'en-US' translation file.
-}
languageFromString : String -> Maybe Language
languageFromString lang =
    let
        helper langs =
            case langs of
                [] ->
                    Maybe.Nothing

                l :: ls ->
                    if String.startsWith (languageToString l) lang then
                        Maybe.Just l

                    else
                        helper ls
    in
    helper (List.reverse languages)


{-| Load translations for identifier 'intro' and a `Language` from the server. This is a simple `Http.get`, if you need more customization,
you can use the `decoder` instead. Pass the path and a callback to your `update` function, for example

    load { language = En, path = "/i18n", onLoad = GotTranslations }

will make a `GET` request to /i18n/intro.en.json and will call GotTranslations with the decoded response.

-}
loadIntro : { language : Language, path : String, onLoad : Result Http.Error (I18n -> I18n) -> msg } -> Cmd msg
loadIntro opts =
    Http.get
        { expect = Http.expectJson opts.onLoad decodeIntro
        , url = opts.path ++ "/" ++ languageToFileName_intro opts.language
        }


headline : I18n -> String
headline (I18n { intro }) =
    case Array.get 0 intro of
        Just translation ->
            translation

        Nothing ->
            ""


inputType : I18n -> String
inputType (I18n { intro }) =
    case Array.get 1 intro of
        Just translation ->
            translation

        Nothing ->
            ""


inputTypeFluent : I18n -> String
inputTypeFluent (I18n { intro }) =
    case Array.get 2 intro of
        Just translation ->
            translation

        Nothing ->
            ""


inputTypeJson : I18n -> String
inputTypeJson (I18n { intro }) =
    case Array.get 3 intro of
        Just translation ->
            translation

        Nothing ->
            ""


inputTypeProperties : I18n -> String
inputTypeProperties (I18n { intro }) =
    case Array.get 4 intro of
        Just translation ->
            translation

        Nothing ->
            ""


stepOne : I18n -> String
stepOne (I18n { intro }) =
    case Array.get 5 intro of
        Just translation ->
            translation

        Nothing ->
            ""


stepThree : I18n -> String
stepThree (I18n { intro }) =
    case Array.get 6 intro of
        Just translation ->
            translation

        Nothing ->
            ""


stepTwo : I18n -> String
stepTwo (I18n { intro }) =
    case Array.get 7 intro of
        Just translation ->
            translation

        Nothing ->
            ""


{-| Decode an `I18n` from Json. Make sure this is _only_ used on the files generated by this package.
-}
decodeIntro : Json.Decode.Decoder (I18n -> I18n)
decodeIntro =
    Json.Decode.array Json.Decode.string |> Json.Decode.map (\arr (I18n i18n) -> I18n { i18n | intro = arr })


intParser : Parser.Parser Int
intParser =
    Parser.chompWhile Char.isDigit
        |> Parser.getChompedString
        |> Parser.andThen
            (String.toInt >> Maybe.map Parser.succeed >> Maybe.withDefault (Parser.problem "Expected int"))


languageToFileName_intro : Language -> String
languageToFileName_intro lang =
    case lang of
        En ->
            "intro.en.json"
